---
layout: post
title: "Lazy loading of JavaScript modules by using dynamic imports and code splitting with Webpack"
description: "Most of the time you have a big JavaScript codebase for your website but you need only a small fraction of it when a page is requested. Is it possible to load chunks of JavaScript code only when they are really needed? Yes you can with Webpack and its code splitting feature based on a syntax equal to the one of ES2020 dynamic imports."
date: 2020-07-01
image: /assets/images/posts/XXX
tags: [web development, javascript]
comments: true
math: false
seo:
 - type: "BlogPosting"
authors: [fabrizio_duroni] 
---

*Most of the time you have a big JavaScript codebase for your website but you need only a small fraction of it when a page is requested. Is it possible to load chunks of JavaScript code only when they are really needed? Yes you can with Webpack and its code splitting feature based on a syntax equal to the one of ES2020 dynamic imports.*

---

Recently I migrated my website (this one you're seeing right now) to TypeScript + WebPack as bundling system. One of the main problem of my website was the dimension of the final JavaScript generated after the bundling for the [home page](/ "fabrizio duroni home"). As a consequence of the fact that this page contains a threejs physically based scene, the size of the `index.home.js` script was over 600 KB :scream:. This was too much, considering also that all this JavaScript was loaded without been used on the mobile version of the website, where this feature was turned off.  
During the last few months of my daily job at lastminute.com I worked on a project that is using Webpack for bundling the JS code. In particular, during the development of a new part of the user personal area I encountered the code splitting with lazy loading feature of Webpack and immediately I thought: "THIS IS WHAT I NEED FOR THE HOMEPAGE OF fabrizioduroni.it". : heart_eyes:  
So let's start and see how I used it on my website so that you can start to optimize your site too!!

#### Implementation

First of all, there are two types of output file generated by Webpack:

- entry files, that are the one main entry points for your application. This are usually the files that you will add with a script tag in your HTML pages (or you can let Webpack add them automatically, but this is a story for another post :smirk:)
- chunk files, that are the one obtained after the code splitting

In a base Webpack configuration file it is usually contained the `entry` property that contains the list of entry files to be bundled. To enable code splitting and chunk files generation we need to add a new entry in the configuration called `chunkFilename`. With this configuration entry we can tell Webpack how to name the chunks file generated. In my case I defined the name as a concatenation of some Webpack built-in environment variable:

- `[name]`, the chunk name
- `[chunkhash]`, the hash generated by Webpack from the content of the chunk generated. If its content is changed than the `chunkhash` will be updated consequently. It is similar to the `[hash]` variable used in the `entry` configuration (but this one is generated from the entire build result).

```diff
{
  mode: 'production',
  entry: {
    'index.home': 'ts/index.home.ts',
    'index.blog': 'ts/index.blog.ts',
  },
  output: {
    filename: '[name].[hash].min.js',
+    chunkFilename: '[name].[chunkhash].bundle.js',
    publicPath: `dist/`,
    path: path.resolve(__dirname, dist),
  },
  module: {
    /*...modules configurations...*/
  },
  /*...other configurations...*/
}
```

.....

```typescript
/* ...other code... */

const isWebGLEnabled = (): boolean => {
  /*...implementation...*/
}

const scene3D = (): void => {
  if (isWebGLEnabled() && !isAMobileDevice()) {
    import(/* webpackChunkName: "scene-threejs" */ './scene-threejs').then(module => module.sceneThreeJS())
  }
}

export { scene3D }
```

#### Conclusion

...
